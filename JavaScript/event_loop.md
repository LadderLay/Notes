# JavaScript 的事件循环（Event Loop）机制

## 单线程的 JavaScript
JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程去提高效率呢。

JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。
JavaScript的两大特点：单线程，非阻塞。而非阻塞的特性正是通过事件循环实现的。

## 事件循环机制

### 执行上下文和执行栈

我们知道，当我们调用一个函数的时候，js会生成一个与这个函数对应的执行环境（context），又叫**执行上下文**。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为**执行栈**。
当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。因为JS执行中最先进入全局环境，所以**处于"栈底的永远是全局环境的执行上下文"**。而处于"栈顶的是当前正在执行函数的执行上下文"。如果当前执行的是一个函数，那么js会向执行栈中添加这个函数的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。
```
function foo () {
    function bar () {
        return 'I am bar';
    }
    return bar();
}
foo();
```
![1](https://s2.ax1x.com/2019/11/09/Mmnm5V.png)
在执行栈中，一个函数执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他函数，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。
以上的过程说的都是同步代码的执行。那么当一个异步代码执行后会如何呢？前文提过，js的另一大特点是非阻塞，实现这一点的关键在于下面要说的这项机制——任务队列（Task Queue）。
### 任务队列
**同步和异步**
如果在函数返回结果的时候，调用者能够拿到预期的结果(就是函数计算的结果)，那么这个函数就是同步的。
如果在函数返回的时候，调用者还不能购得到预期结果，而是将来通过一定的手段得到（例如回调函数），这就是异步。
而js是单线程的，这意味着所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。我们会发现，很多时候，在同步的情况下，cpu 的资源是闲置着的，因此，JavaScript语言的设计者意识到，这时主线程完全可以挂起处于等待中的任务，先运行排在后面的任务。等到前面的任务返回了结果，再回过头，把挂起的任务继续执行下去。

具体来说，异步执行的运行机制如下：
```
（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。

（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

（4）主线程不断重复上面的第三步。
```
![2](https://developer.mozilla.org/files/4617/default.svg)这是 MDN 上的一张理论模型图。

被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。

以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。他们的执行优先级也有区别。

## 参考链接
- [MDN:并发模型与事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop)
- [详解JavaScript中的Event Loop（事件循环）机制](https://zhuanlan.zhihu.com/p/33058983)
- [阻塞与非阻塞](https://segmentfault.com/a/1190000019278998?utm_source=tag-newest)
- [执行上下文和执行栈](https://segmentfault.com/a/1190000017890535)

## 概念
- 上下文 & 作用域
- 执行上下文 & 执行栈
- 浏览器环境下的事件循环机制 & node 环境下的事件循环机制
